# 1. Абстрактная фабрика (Abstract Factory)
__Суть:__
Создание семейств связанных объектов без указания их конкретных классов.

Простыми словами, __Абстрактная фабрика__ предоставляет интерфейс для создания семейств взаимосвязанных объектов, но не ___специфицирует конкретных классов__.
Предназначен для создания семейств объектов.
И с фабриками и с продуктами ы работаем на уроне интерфейса.

## Основные компоненты абстрактной фабрики
* __Абстрактный фабричный интерфейс:__ Этот интерфейс определяет набор методов для создания различных абстрактных типов продуктов. Каждый метод в интерфейсе соответствует отдельному семейству продуктов.
* __Конкретные фабрики:__ Классы конкретных фабрик реализуют интерфейс абстрактной фабрики. Каждая конкретная фабрика отвечает за создание определенного семейства связанных продуктов.
* __Абстрактные интерфейсы продукта:__ Эти интерфейсы определяют структуру и поведение объектов продукта, создаваемых фабрикой. Каждое семейство продуктов имеет свой набор абстрактных интерфейсов продукта.
* __Конкретные продукты:__ Классы конкретных продуктов реализуют абстрактные интерфейсы продуктов. Эти классы представляют собой реальные объекты, которые будет использовать клиентский код.
* __Клиент:__ Клиентский код работает с абстрактной фабрикой и абстрактными интерфейсами продуктов. Ему не нужно знать конкретные классы продуктов, которые он использует. Вместо этого он полагается на фабрику, которая создаёт совместимые объекты.
## Диаграмма паттерна Абстрактная фабрика
<figure>
    <img src ="/assets/images/UML_Diagram_Abstract_Factory.png" alt = "Abstract Factory">
</figure>

## пример
```c++
// Абстрактные продукты
class Button {
public:
    virtual void render() = 0;
};

class Checkbox {
public:
    virtual void render() = 0;
};

// Конкретные продукты для Windows
class WinButton : public Button {
    void render() override { std::cout << "Windows Button\n"; }
};

class WinCheckbox : public Checkbox {
    void render() override { std::cout << "Windows Checkbox\n"; }
};

// Абстрактная фабрика
class GUIFactory {
public:
    virtual Button* createButton() = 0;
    virtual Checkbox* createCheckbox() = 0;
};

// Конкретная фабрика для Windows
class WinFactory : public GUIFactory {
public:
    Button* createButton() override { return new WinButton(); }
    Checkbox* createCheckbox() override { return new WinCheckbox(); }
};
```
## Плюсы:
✅ Позволяет создавать совместимые объекты.
✅ Изолирует конкретные классы от клиентского кода.

## Минусы:
❌ Сложность добавления новых продуктов (нужно менять все фабрики).

## Когда применять?
1. Когда система должна быть независимой от способа создания объектов.
2. Когда нужно создавать семейства связанных объектов.