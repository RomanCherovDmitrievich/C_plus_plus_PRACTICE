# 3. Фабричный метод (Factory Method)
__Суть:__
Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.

Шаблон проектирования «__Метод фабрики__» — это шаблон проектирования для создания объектов, используемый при разработке программного обеспечения. Он предоставляет интерфейс для создания объектов в суперклассе, позволяя подклассам указывать типы создаваемых объектов.
* Этот шаблон упрощает процесс создания объекта, помещая его в отдельный метод, что способствует слабой связанности между создателем объекта и самими объектами.
* Такой подход повышает гибкость, расширяемость и удобство сопровождения, позволяя подклассам реализовывать собственные фабричные методы для создания объектов определённых типов.

## Основные компоненты фабричного метода
* __Создатель:__ Это абстрактный класс или интерфейс, в котором объявлен фабричный метод. Создатель обычно содержит метод, который служит фабрикой для создания объектов. Он также может содержать другие методы, работающие с созданными объектами.
* __Конкретный создатель:__ классы Concrete Creator являются подклассами класса Creator и реализуют фабричный метод для создания объектов определённых типов. Каждый конкретный создатель отвечает за создание определённого продукта.
* __Продукт:__ Это интерфейс или абстрактный класс для объектов, создаваемых фабричным методом. Продукт определяет общий интерфейс для всех объектов, которые может создавать фабричный метод.
* __Конкретный продукт:__ классы конкретных продуктов — это реальные объекты, которые создаются фабричным методом. Каждый класс конкретного продукта реализует интерфейс Product или расширяет абстрактный класс Product.

## Диаграмма паттерна Фабричный метод
<figure>
    <img src ="/assets/images/Diagram_Method_Factory.webp" alt = "Method_Factory">
</figure>

## Пример
```c++
class Document {
public:
    virtual void open() = 0;
};

class TextDocument : public Document {
    void open() override { std::cout << "Opening text document...\n"; }
};

// Абстрактный создатель
class Application {
public:
    virtual Document* createDocument() = 0;
    void openDocument() {
        Document* doc = createDocument();
        doc->open();
    }
};

// Конкретный создатель
class TextEditor : public Application {
    Document* createDocument() override { return new TextDocument(); }
};
```
## Плюсы:
✅ Гибкость в создании объектов.
✅ Избегает жёсткой привязки к конкретным классам.

## Минусы:
❌ Может привести к созданию множества подклассов.

## Когда применять?
1. Когда классу заранее неизвестно, объекты каких классов ему нужно создавать.