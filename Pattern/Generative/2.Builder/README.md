# 2. Строитель (Builder)
__Суть:__
Пошаговое создание сложного объекта с помощью одного и того же процесса.

Шаблон проектирования «Строитель» — это шаблон создания, который отделяет конструирование сложного объекта от его представления, позволяя нам создавать различные представления объекта с помощью одного и того же процесса конструирования. Это полезно, когда у объекта много необязательных свойств или конфигураций.

## Ключевые компоненты шаблона проектирования «Строитель» в C++
* __Директор:__ Директор — это основной компонент шаблона проектирования «Строитель». Он отвечает за процесс создания программы. Он работает с «Строителем» над созданием объекта. Директор знает, какие шаги необходимо предпринять для создания объекта, но не знает подробностей реализации каждого шага.
* __Конструктор:__ Конструктор — это основной интерфейс или абстрактный класс, определяющий этапы создания объекта.
* __Concrete Builder:__ По сути, это классы, реализующие интерфейс Builder. Каждый Concrete Builder отвечает за создание конкретного варианта объекта.
* __Продукт:__ Продукт — это сложный объект, который мы хотим создать. В классе Product могут быть методы для доступа к этим компонентам или управления ими. Часто он состоит из нескольких частей или компонентов, которые создаются с помощью конструктора.

## Диаграмма паттерна Строителя
<figure>
    <img src ="/assets/images/Diagram_Builder.png" alt = "Builder">
</figure>

## Пример
```c++
class Pizza {
public:
    void setDough(const std::string& dough) { this->dough = dough; }
    void setSauce(const std::string& sauce) { this->sauce = sauce; }
    void show() const { std::cout << "Pizza with " << dough << " and " << sauce << "\n"; }

private:
    std::string dough;
    std::string sauce;
};

class PizzaBuilder {
public:
    virtual void buildDough() = 0;
    virtual void buildSauce() = 0;
    virtual Pizza* getPizza() = 0;
};

class HawaiianPizzaBuilder : public PizzaBuilder {
public:
    HawaiianPizzaBuilder() { pizza = new Pizza(); }
    void buildDough() override { pizza->setDough("cross"); }
    void buildSauce() override { pizza->setSauce("mild"); }
    Pizza* getPizza() override { return pizza; }

private:
    Pizza* pizza;
};

// Директор управляет процессом сборки
class Cook {
public:
    void makePizza(PizzaBuilder* builder) {
        builder->buildDough();
        builder->buildSauce();
    }
};
```
## Преимущества шаблона проектирования Строитель
✅ __Создание сложных объектов:__ Это упрощает создание сложных объектов за счёт разделения процесса конструирования на ряд чётко определённых этапов. Каждый этап посвящён определённому аспекту конфигурации объекта.

✅ __Возможность повторного использования:__ Конструкторы можно использовать повторно для создания похожих объектов с разными конфигурациями. Такое повторное использование может привести к созданию более эффективного и удобного в сопровождении кода.

✅ __Проверка параметров:__ Разработчики могут проверять параметры в процессе создания, чтобы гарантировать, что для создания объектов используются только допустимые конфигурации.

## Недостатки шаблонов проектирования Строитель
❌ __Избыточный код:__ Для реализации шаблона проектирования «Строитель» может потребоваться написание дополнительного кода для классов-конструкторов, что может усложнить кодовую базу, особенно для простых объектов.

❌ __Кривая обучения:__ Разработчикам, не знакомым с шаблоном проектирования «Строитель», может потребоваться некоторое время, чтобы понять его концепцию и научиться правильно его реализовывать.

❌ __Возможность создания неполных объектов:__ Если клиентский код забывает вызывать определенные методы конструктора, могут создаваться неполные или несогласованные объекты, что приводит к ошибкам во время выполнения.

## Когда применять?
1. Когда объект требует сложной инициализации.
2. Когда нужно собирать объекты с разными конфигурациями.