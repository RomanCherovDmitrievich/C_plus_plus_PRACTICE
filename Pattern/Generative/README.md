# Generative patterns (Порождающие паттерны)
Порождающие паттерны решают задачи создания объектов,


| Паттерн | Основная цель | Когда использовать? |
| -------- | --------- | --------- |
| 1.Abstract Factory | Создание семейств объектов | Кросс-платформенные UI, БД-драйверы |
| 2.Builder | Пошаговая сборка сложных объектов | Конфигурация объектов (Pizza, Car) |
| 3.Factory Method | Делегирование создания подклассам | Плагины, фреймворки |
| 4.Prototype | Клонирование объектов | Оптимизация создания объектов |
| 5.Singleton | Единственный экземпляр класса | Логгеры, настройки, глобальные объекты |

## Общие преимущества порождающих паттернов
✅ Гибкость – позволяют менять способ создания объектов без изменения кода.

✅ Избегание дублирования – инкапсулируют логику создания, уменьшая повторяющийся код.

✅ Контроль над процессом – дают чёткие правила для инстанцирования объектов.

✅ Тестируемость – Упрощают подмену реальных объектов на заглушки (моки).

##  Общие сложности порождающих паттернов
❌ Усложнение архитектуры – вводят дополнительные классы и интерфейсы.

❌ Избыточность для простых случаев – если объекты создаются тривиально, паттерны могут быть излишни.

❌ Сложность отладки – многоуровневое создание объектов усложняет понимание кода.

## Когда не стоит использовать порождающие паттерны?
1. Если объекты создаются просто (например, через new Class()).
2. Если архитектура становится слишком сложной из-за паттернов.
3. Если паттерн не решает конкретную проблему (используйте их осознанно!).

| Паттерн |	Лучшие случаи применения | Основные сложности |
| ------- | ----------- | --------- |
| Abstract Factory | Кросс-платформенные библиотеки | Сложность добавления новых продуктов |
| Builder | Сложные объекты (Car, Pizza) | Много boilerplate-кода |
| Factory Method | Плагины, фреймворки	| Разрастание подклассов |
| Prototype | Объекты с дорогим созданием | Проблемы с глубоким копированием |
| Singleton | Глобальные менеджеры (Logger, Config) | Нарушает тестируемость и SOLID |