# 6. Observer (Наблюдатель)
__Суть:__
Определяет зависимость "один-ко-многим" между объектами: при изменении состояния одного объекта все зависящие от него оповещаются.

Паттерн «__Наблюдатель__» — это поведенческий паттерн проектирования, который определяет зависимость «один ко многим» между объектами. Это означает, что когда один объект (субъект) меняет своё состояние, все зависимые от него объекты (наблюдатели) получают уведомление и автоматически обновляются. Этот паттерн используется для создания распределённых систем обработки событий и является важной частью многих программных архитектур, включая модель-представление-контроллер (MVC).

## Задача
>_Предположим, вы разрабатываете приложение для мониторинга погоды, в котором несколько метеостанций отвечают за сбор данных о погоде, и вы хотите создать систему, в которой на нескольких дисплеях будут отображаться обновления данных о погоде в режиме реального времени. Когда метеостанция собирает новые данные, все зарегистрированные дисплеи должны автоматически обновляться с учетом последней информации._

## Ключевые моменты паттерна Наблюдатель
* __Тема:__ Это объект, за которым ведётся наблюдение. Он ведёт список наблюдателей и уведомляет их об изменениях состояния.
* __Наблюдатель:__ Наблюдатели — это объекты, которым интересны изменения состояния субъекта. Они регистрируются у субъекта, чтобы получать обновления.
* __Конкретный объект:__ Конкретный объектный класс наследуется от объектного интерфейса или класса и отвечает за поддержание состояния и уведомление наблюдателей о происходящих изменениях.
* __Конкретный наблюдатель:__ Конкретные наблюдатели реализуют интерфейс наблюдателя или наследуются от класса наблюдателя. Они регистрируются у конкретного субъекта и реагируют на изменения состояния.

## Пример
```c++
#include <iostream>
#include <vector>
#include <algorithm>

class Observer {
public:
    virtual void update(const std::string& message) = 0;
};

class Subject {
    std::vector<Observer*> observers;
public:
    void attach(Observer* obs) { observers.push_back(obs); }
    void detach(Observer* obs) {
        observers.erase(std::remove(observers.begin(), observers.end(), obs), observers.end());
    }
    void notify(const std::string& message) {
        for (auto obs : observers) obs->update(message);
    }
};

class ConcreteObserver : public Observer {
    std::string name;
public:
    ConcreteObserver(const std::string& n) : name(n) {}
    void update(const std::string& message) override {
        std::cout << name << " received: " << message << std::endl;
    }
};

int main() {
    Subject subject;
    ConcreteObserver obs1("Observer 1");
    ConcreteObserver obs2("Observer 2");

    subject.attach(&obs1);
    subject.attach(&obs2);

    subject.notify("Hello, observers!");  // Оба получат сообщение

    subject.detach(&obs1);
    subject.notify("Observer 1 detached");  // Только obs2 получит

    return 0;
}
```

## Преимущества шаблона проектирования «Наблюдатель» в C++
✅ __Разделение:__ Шаблон проектирования «Наблюдатель» способствует разделению связей между субъектами и наблюдателями. Субъектам не нужно знать конкретные типы своих наблюдателей.
✅ __Масштабируемость:__ Вы можете легко добавлять или удалять наблюдателей без изменения объекта. Это делает его гибким решением для систем с динамическими требованиями.
✅ __Возможность повторного использования:__ Наблюдателей можно повторно использовать в различных контекстах, если они соответствуют интерфейсу или классу наблюдателя.
✅ __Обработка событий:__ Этот шаблон используется в системах обработки событий, таких как фреймворки для графического пользовательского интерфейса, где компоненты должны реагировать на действия пользователя.

## Недостатки шаблона проектирования «Наблюдатель» в C++
❌ __Издержки, связанные с памятью и производительностью:__ Использование динамических списков наблюдателей может привести к увеличению объёма используемой памяти, а уведомление большого количества наблюдателей может повлиять на производительность в крупномасштабных системах.
❌ __Порядок уведомления:__ В некоторых случаях порядок уведомления наблюдателей может иметь значение, но этот шаблон не гарантирует соблюдение определённого порядка.
❌ __Непреднамеренные обновления:__ Наблюдатели могут получать обновления, даже если их не интересуют определённые изменения, что приводит к потенциально ненужной обработке данных.

## Где применяется?
1. UI (кнопки → обработчики событий).
2. Рассылка уведомлений.
3. Модель MVC (обновление View при изменении Model).