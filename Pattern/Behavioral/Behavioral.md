# Behavioral Patterns (Поведенческие паттерны)
__Поведенческие паттерны__ решают задачи организации взаимодействия между объектами и распределения ответственности в коде. Они не создают объекты (как порождающие) и не структурируют иерархии классов (как структурные), а управляют поведением системы.

| Паттерн | Основная идея | Когда использовать |
|-------|--------|-------|
| 1. Chain of Responsibility | Передает запрос по цепочке обработчиков. | Когда нужно поочередно проверять условия (аутентификация → валидация → логирование). Фильтрация, middleware |
| 2. Command | Инкапсуляция запрос как объект |	Для отложенного выполнения, отмены операций (undo/redo), очередей задач |
| 3. Iterator | Единый интерфейс для обхода коллекций | Когда нужно скрыть внутреннюю структуру данных (STL, деревья, графы) |
| 4. Mediator | Централизует взаимодействие объектов через посредника | Для сложных систем с множеством связей (чат-боты, UI-фреймворки)|
| 5. Memento | Сохранение и восстановление состояния объекта | Для отката изменений (Ctrl+Z, сохранение игры) |
| 6. Observer | Уведомления об изменениях "подписчиках" | Для событийных систем (GUI, уведомления, MVC) |
| 7. State | Изменение поведения при смене внутреннего состояния | Когда состояний много и переходы между ними сложны (документы, игровые персонажи) |
| 8. Strategy | Инкапсулирует семейство алгоритмов для взаимозаменяемого использования | Когда нужно выбирать алгоритм на лету (сортировка, оплата, шифрование) |
| 9. Template Method | Определяет скелет алгоритма, позволяя подклассам переопределять шаги | Для стандартизации процесса (инициализация → выполнение → очистка) |
| 10. Visitor |	Добавляет операции к объектам без изменения их классов | Для разделения алгоритмов и структур данных (компиляторы, сериализация) |

## Похожие паттерны
### State vs Strategy
| Аспект | State (Состояние) | Strategy (Стратегия) |
|--------| -------- | ------- |
| Цель | Менять поведение объекта при смене его внутреннего состояния |	Предоставить разные алгоритмы, которые можно подменять динамически |
| Управление переключением | Контекст автоматически меняет состояние (например, при вызове методов) | Клиент явно выбирает стратегию (например, через setStrategy( )) |
| Зависимость между вариантами | Состояния знают друг о друге (например, StateA может переключить контекст в StateB) | Стратегии независимы и не связаны между собой |

#### У State:
1. Состояния сами управляют переходом
2. Клиентский код не контролирует смену состояний.
#### У Strategy
1. Стратегии не знают друг о друге.
2. Клиент сам решает, какой алгоритм использовать.

### Observer vs Mediator
| Аспект |Observer (Наблюдатель) | Mediator (Посредник) |
|-------| -------------| ---------|
| Цель | Рассылка событий многим подписчикам | Централизованное управление взаимодействием объектов |
| Связность | Прямая связь Subject-Observer (1-to-N) | Все общение идет через Mediator (N-to-N) |
| Кто инициирует обмен | Subject уведомляет Observers | Объекты отправляют запросы Mediator'у |
| Пример из жизни | Уведомления в мессенджере | Диспетчер такси |

### Command vs Memento
| Аспект | Command (Команда) | Memento (Снимок) |
| ------ | ------ | ------| 
| Цель | Инкапсулировать действие | Сохранить состояние объекта | 
| Что хранится | Параметры для выполнения операции | Снимок внутреннего состояния |
| Отмена операции |	Через обратную команду (undo) | Восстановление из снимка |
| Пример из жизни |	Пульт ДУ (кнопки → действия) | Сохранение игры |

### Template Method vs Strategy
| Аспект | Template Method (Шаблонный метод) | Strategy (Стратегия) |
| ------- | ------------- | ----------- |
| Цель | Фиксирует структуру алгоритма | Позволяет менять алгоритм |
| Гибкость | Низкая (шаги зафиксированы) | Высокая (алгоритм подменяется) |
| Принцип | Наследование | Композиция |
| Пример из жизни | Рецепт с обязательными шагами | Выбор маршрута в навигаторе |

## Проблемы 
1. __Сложность отладки:__
Поведение системы становится распределённым (например, Observer или Chain of Responsibility).
Решение: Добавлять логгирование вызовов.

2. __Многопоточность:__
Большинство паттернов не потокобезопасны из коробки
Пример: Наблюдатель может вызвать update() у удалённого объекта.
Решение: Использовать std::mutex или std::atomic.

3. __Производительность:__
Виртуальные вызовы (virtual методы) медленнее обычных.
Решение: В высоконагруженных системах заменять на std::function или шаблоны.

4. __Утечки памяти:__
Если паттерн использует new (например, Strategy), нужно не забывать delete.
Решение: Переходить на std::unique_ptr.

## Вывод
__Поведенческие паттерны__ — это мощный инструмент для управления сложной логикой, но они требуют:
✅ Аккуратной работы с памятью
✅ Учёта многопоточности
✅ Тестирования всех сценариев взаимодействия

Используйте их там, где гибкость важнее производительности, и всегда оценивайте, не усложняет ли паттерн код.