# 2. Command (Команда)
__Суть:__
Инкапсулирует запрос в виде объекта, позволяя параметризовать клиенты с разными запросами, ставить их в очередь или поддерживать отмену операций.

Шаблон проектирования «__Команда__» — это поведенческий шаблон проектирования, который позволяет инкапсулировать запрос в виде объекта, тем самым отделяя отправителя запроса от получателя. Этот шаблон позволяет параметризовать объекты с помощью команд, откладывать выполнение запроса или ставить его в очередь, а также поддерживать операции с возможностью отмены. Это фундаментальный шаблон для реализации широкого спектра функций в программных системах.

## Задача 
>_Разработайте систему, демонстрирующую использование шаблона проектирования «Команда» для разделения отправителя и получателя запроса. Система должна состоять из нескольких ключевых компонентов: команды, конкретной команды, получателя и вызывающего объекта._

## Ключевые компоненты паттерна Команда
1. Интерфейс командной строки или абстрактный класс
Это интерфейс или абстрактный класс, в котором объявлен метод execute, определяющий контракт для конкретных команд. Это гарантирует, что во всех командах есть метод для выполнения их действий.
2. Конкретная команда
Конкретные классы команд реализуют интерфейс Command или наследуются от абстрактного класса. Каждая конкретная команда инкапсулирует определённое действие, которое необходимо выполнить. Например, у вас могут быть конкретные команды для включения света, открытия файлов или отправки сообщений.
3. Приемник
Приёмник отвечает за выполнение фактической работы при получении команды. Он знает, как выполнить запрошенное действие. Например, в системе домашней автоматизации приёмником может быть объект «Свет», который понимает, как включать и выключать свет.
4. Вызывающий
Инвокер отвечает за запуск выполнения команд. Он хранит ссылки на команды и может их выполнять. Он выступает в роли посредника между отправителем (клиентом) и получателем, обеспечивая независимость отправителя от получателя.

## Пример
```c++
#include <iostream>
#include <vector>

class Command {
public:
    virtual void execute() = 0;
};

class Light {
public:
    void on() { std::cout << "Light is ON\n"; }
    void off() { std::cout << "Light is OFF\n"; }
};

class LightOnCommand : public Command {
    Light& light;
public:
    LightOnCommand(Light& l) : light(l) {}
    void execute() override { light.on(); }
};

class LightOffCommand : public Command {
    Light& light;
public:
    LightOffCommand(Light& l) : light(l) {}
    void execute() override { light.off(); }
};

class RemoteControl {
    std::vector<Command*> commands;
public:
    void addCommand(Command* cmd) { commands.push_back(cmd); }
    void pressButton(int slot) {
        if (slot < commands.size()) commands[slot]->execute();
    }
};

int main() {
    Light light;
    LightOnCommand onCmd(light);
    LightOffCommand offCmd(light);

    RemoteControl remote;
    remote.addCommand(&onCmd);
    remote.addCommand(&offCmd);

    remote.pressButton(0);  // Включает свет
    remote.pressButton(1);  // Выключает свет
    return 0;
}
```
## Преимущества шаблона проектирования Команда:
✅ __Разделение отправителя и получателя:__ Шаблон проектирования «Команда» отделяет отправителя запроса от получателя, то есть отправителю не нужно знать, как именно обрабатывается запрос. Такое разделение способствует созданию более гибкой и удобной в сопровождении кодовой базы.

✅ __Очередь команд:__ Команды можно легко ставить в очередь, что позволяет реализовать такие функции, как отмена и повтор. Это особенно полезно в приложениях, где важен порядок выполнения команд.

✅ __Ведение журнала и аудит:__ Поскольку каждая команда инкапсулирована в виде объекта, вести журнал и аудит выполняемых команд становится проще. Это полезно для отслеживания поведения системы и отладки.

✅ __Расширяемость:__ Шаблон проектирования «Команда» позволяет легко добавлять новые команды и расширять функциональность приложения без изменения существующего кода. Вы можете создавать новые классы команд, не затрагивая существующие классы.

✅ __Поддержка составных команд:__ Создавая составные команды (команды, содержащие другие команды), вы можете реализовывать сложные операции. Это полезно, когда вам нужно выполнить последовательность действий с помощью одной команды.

✅ __Инкапсуляция состояния:__ Команды могут инкапсулировать состояние, необходимое для их выполнения. Такая инкапсуляция гарантирует, что команда будет обладать всей информацией, необходимой для выполнения действия.

## Недостатки шаблона проектирования Команда:
❌ __Сложность кода:__ Реализация шаблона проектирования «Команда» может привести к усложнению иерархии классов, особенно при работе с различными типами команд и получателей. Такая дополнительная сложность может оказаться чрезмерной для простых систем.

❌ __Увеличение потребления памяти:__ Поскольку каждая команда представлена в виде объекта, может увеличиться потребление памяти, особенно при работе с большим количеством команд. Это может быть неприемлемо для систем с ограниченным объемом памяти.

❌ __Возможное снижение производительности:__ Использование команд и их выполнение могут привести к незначительному снижению производительности из-за косвенного обращения к инкапсуляции запросов в виде объектов. В приложениях, где важна производительность, это может стать проблемой.

❌ __Кривая обучения:__ Понимание и реализация шаблона проектирования «Команда» могут оказаться сложными для разработчиков, которые только начинают изучать шаблоны проектирования. Для эффективного использования этого шаблона может потребоваться дополнительное обучение и опыт.

❌ __Ограниченные сценарии использования:__ Шаблон проектирования «Команда» не всегда является лучшим выбором для любого сценария. Он наиболее эффективен в системах, где необходимо разделить отправителей и получателей, реализовать функции отмены/возврата или логирования команд. В более простых системах он может быть не нужен.

## Где применяется?
1. GUI (кнопки, меню).
2. Очереди задач (например, в многопоточных приложениях).
3. Транзакции (откат изменений).