# 1. Chain of Responsibility (Цепочка обязанностей)
__Суть:__
Позволяет передавать запросы последовательно по цепочке обработчиков. Каждый обработчик решает, обработать запрос или передать дальше.

Шаблон «__Цепочка ответственности__» — это поведенческий шаблон, который позволяет объекту отправлять запросы другим объектам, не зная, кто их обработает. Этот шаблон часто используется в цепочке из нескольких объектов, где каждый объект либо обрабатывает запрос, либо передаёт его следующему объекту в цепочке, если не может его обработать. Этот шаблон способствует слабой связанности между отправителем и получателем, предоставляя свободу в обработке запроса.

## Задача
>_Предположим, нам нужно обрабатывать запросы на аутентификацию с помощью цепочки обработчиков.  В зависимости от типа запроса на аутентификацию его обрабатывает соответствующий обработчик в цепочке или он передаётся по цепочке до тех пор, пока обработчик не сможет его обработать или пока не будет достигнут конец цепочки._
## Ключевой компонент паттерна Цепочка ответственности
* __Интерфейс обработчика или абстрактный класс:__ Это базовый класс, который определяет интерфейс для обработки запросов и, во многих случаях, для перехода к следующему обработчику в цепочке.
* __Конкретные обработчики:__ Это классы, которые реализуют обработку запросов. Они могут обработать запрос или передать его следующему обработчику в цепочке, если он не может обработать этот запрос.
* __Клиент:__ Запрос отправляется клиентом, который затем перенаправляет его первому обработчику в цепочке. Какой обработчик в итоге обработает запрос, клиенту неизвестно.

## Диаграмма паттерна Цепочка ответственности
<figure>
    <img src ="/assets/images/Diagram_Chain_of_Responsibility.jpg" alt = "Chain_of_Responsibility">
</figure>

## Пример
```c++
#include <iostream>
#include <string>

class Handler {
protected:
    Handler* next;
public:
    Handler() : next(nullptr) {}
    void setNext(Handler* handler) { next = handler; }
    virtual void handleRequest(const std::string& request) = 0;
};

class ConcreteHandlerA : public Handler {
public:
    void handleRequest(const std::string& request) override {
        if (request == "A") {
            std::cout << "Handler A: Processing request '" << request << "'\n";
        } else if (next) {
            next->handleRequest(request);
        }
    }
};

class ConcreteHandlerB : public Handler {
public:
    void handleRequest(const std::string& request) override {
        if (request == "B") {
            std::cout << "Handler B: Processing request '" << request << "'\n";
        } else if (next) {
            next->handleRequest(request);
        }
    }
};

int main() {
    ConcreteHandlerA handlerA;
    ConcreteHandlerB handlerB;
    handlerA.setNext(&handlerB);

    handlerA.handleRequest("A");  // Обработает HandlerA
    handlerA.handleRequest("B");  // Обработает HandlerB
    handlerA.handleRequest("C");  // Не обработает никто
    return 0;
}
```
## Преимущества шаблона проектирования Цепочка ответственности
✅ __Разделение объектов:__ Этот шаблон позволяет отправлять запрос нескольким возможным получателям, не беспокоясь о том, какой объект в итоге его обработает. Это снижает зависимость между элементами.

✅ __Гибкость и расширяемость:__ Можно легко добавлять новые обработчики или изменять существующие, не затрагивая клиентский код. Это повышает гибкость и расширяемость системы.

✅ __Динамический порядок обработки:__ Последовательность и порядок обработки запросов могут динамически изменяться во время выполнения, что позволяет корректировать логику обработки в соответствии с требованиями.

✅ __Упрощённое взаимодействие объектов:__ Это упрощает взаимодействие между объектами-отправителями и объектами-получателями, поскольку отправителю не нужно знать о логике обработки.

✅ __Повышенная ремонтопригодность:__ Каждый обработчик выполняет определённый тип обработки, что упрощает обслуживание и модификацию отдельных компонентов без ущерба для системы в целом.

## Недостатки шаблона проектирования Цепочка ответственности
❌ __Возможные необработанные запросы:__ Цепочка должна быть реализована правильно, иначе некоторые запросы могут вообще не обрабатываться, что приведёт к непредвиденному поведению приложения.

❌ __Накладные расходы на производительность:__ Если запрос длинный и сложный, он будет проходить через несколько обработчиков в цепочке, что может привести к снижению производительности. Логика обработки каждого обработчика влияет на общую производительность системы.

❌ __Сложность отладки:__ Тот факт, что в цепочке задействовано несколько обработчиков, может усложнить отладку. Отслеживать ход выполнения запроса и определять, какой обработчик отвечает за его обработку, может быть непросто.

❌ __Издержки, связанные с конфигурацией во время выполнения:__ Управление цепочкой ответственности и её поддержка могут усложниться, если цепочка будет динамически изменяться во время выполнения.

## Где применяется?
1. Логирование (разные уровни логов).
2. Обработка событий в GUI (например, кнопка → диалог → главное окно).
3. Фильтрация запросов (например, аутентификация → авторизация → валидация).