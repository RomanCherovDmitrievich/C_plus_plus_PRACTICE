# 4. Mediator (Посредник)
__Суть:__
Уменьшает связанность множества классов, перенося логику взаимодействия в отдельный класс-посредник.

Шаблон проектирования «__Посредник__» — один из важных и широко используемых шаблонов поведенческого проектирования. Посредник определяет объект-посредник для централизации взаимодействия между различными компонентами или объектами в системе. Это способствует слабой связанности, предотвращая прямое взаимодействие между компонентами и заставляя их взаимодействовать через посредника, что повышает удобство сопровождения и гибкость архитектуры системы.
* Если объекты взаимодействуют друг с другом напрямую, компоненты системы тесно связаны между собой, что повышает стоимость обслуживания и затрудняет расширение.
* Паттерн «Посредник» предполагает наличие посредника между объектами для обеспечения связи и помогает реализовать слабую связанность между объектами.

## Ключевые компоненты паттерна Посредник
1. __Посредник__
Интерфейс Mediator определяет контракт на взаимодействие, указывая методы, которые должны быть реализованы в конкретных медиаторах для облегчения взаимодействия между коллегами. Он инкапсулирует логику координации и управления взаимодействием между этими объектами, обеспечивая слабую связанность и централизованный контроль над их взаимодействием.

2. __Коллега__
Коллегиальные классы — это компоненты или объекты, которые взаимодействуют друг с другом. Они взаимодействуют через посредника, и каждый коллегиальный класс знает только о посреднике, а не о других коллегиальных классах. Такая изоляция гарантирует, что изменения в одном коллегиальном классе не повлияют напрямую на другие.

3. __Конкретный посредник__
Concrete Mediator — это конкретная реализация интерфейса Mediator. Он координирует взаимодействие между конкретными объектами-коллегами, обрабатывает их взаимодействия и обеспечивает слаженную совместную работу, сохраняя при этом их автономность.

4. __Конкретный коллега__
Конкретные классы-коллеги — это конкретные реализации интерфейса Colleague. Они взаимодействуют с другими коллегами через посредника, что позволяет избежать прямых зависимостей и создать более гибкую и удобную в обслуживании архитектуру системы.

## Диаграмма паттерна Посредник
<figure>
    <img src ="/assets/images/Diagram_Mediator.webp" alt = "Mediator">
</figure>

## Пример
```c++
#include <iostream>
#include <string>

class Mediator;

class Colleague {
protected:
    Mediator* mediator;
public:
    Colleague(Mediator* m) : mediator(m) {}
};

class Mediator {
public:
    virtual void notify(Colleague* sender, const std::string& event) = 0;
};

class ConcreteColleagueA : public Colleague {
public:
    ConcreteColleagueA(Mediator* m) : Colleague(m) {}
    void doSomething() {
        std::cout << "ColleagueA triggers event.\n";
        mediator->notify(this, "A");
    }
};

class ConcreteColleagueB : public Colleague {
public:
    ConcreteColleagueB(Mediator* m) : Colleague(m) {}
    void react() { std::cout << "ColleagueB reacts.\n"; }
};

class ConcreteMediator : public Mediator {
    ConcreteColleagueA* colleagueA;
    ConcreteColleagueB* colleagueB;
public:
    void setColleagues(ConcreteColleagueA* a, ConcreteColleagueB* b) {
        colleagueA = a;
        colleagueB = b;
    }
    void notify(Colleague* sender, const std::string& event) override {
        if (event == "A") colleagueB->react();
    }
};

int main() {
    ConcreteMediator mediator;
    ConcreteColleagueA colleagueA(&mediator);
    ConcreteColleagueB colleagueB(&mediator);
    mediator.setColleagues(&colleagueA, &colleagueB);

    colleagueA.doSomething();  // ColleagueB reacts.
    return 0;
}
```

## Плюсы:
✅ Уменьшает связанность компонентов.
✅ Упрощает взаимодействие множества объектов.

## Минусы:
❌ Посредник может превратиться в "божественный объект" -  антипаттерн объектно-ориентированного программирования. Он описывает объект, который хранит в себе «слишком много» или делает «слишком много».

## Когда следует использовать шаблон проектирования «Посредник»
* __Сложная коммуникация:__ Ваша система состоит из набора объектов, которые должны взаимодействовать друг с другом сложным образом, и вы хотите избежать прямых зависимостей между ними.
* __Слабая связанность:__ Вы хотите обеспечить слабую связанность между объектами, чтобы они могли взаимодействовать, не зная подробностей реализации друг друга.
* __Централизованное управление:__ Вам нужен централизованный механизм для координации и управления взаимодействием между объектами, чтобы система была более организованной и удобной в обслуживании.
* __Изменения в поведении:__ Вы ожидаете изменений в поведении компонентов и хотите инкапсулировать эти изменения в медиаторе, чтобы предотвратить масштабные модификации.
* __Расширенные возможности повторного использования:__ Вы хотите повторно использовать отдельные компоненты в разных контекстах без изменения их внутренней логики или способов взаимодействия.

## Когда не следует использовать шаблон проектирования «Посредник» в C++
* __Простые взаимодействия:__ Взаимодействие между компонентами происходит напрямую, и введение посредника только усложнит ситуацию.
* __Принцип единой ответственности (Single Responsibility Principle, SRP):__ Каждый компонент отвечает за что-то одно, и введение посредника может нарушить принцип единой ответственности, что приведёт к снижению удобства сопровождения кода.
* __Проблемы с производительностью:__ Использование посредника может привести к снижению производительности, особенно в ситуациях, когда прямое взаимодействие между компонентами более эффективно.
* __Небольшие приложения:__ В небольших приложениях с ограниченным количеством компонентов затраты на внедрение посредника могут превысить его преимущества.
* __Чрезмерная сложность:__ Не используйте шаблон «Посредник», если он кажется вам слишком сложным для конкретных требований вашей системы. Всегда учитывайте компромиссы и конкретные потребности вашего приложения.

## Где применяется?
1. Чат-боты (обработка сообщений).
2. UI-фреймворки (взаимодействие виджетов).