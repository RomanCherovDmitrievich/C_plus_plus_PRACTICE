# 10. Visitor (Посетитель)
__Суть:__
Позволяет добавлять новые операции к объектам без изменения их классов.

Шаблон проектирования «Посетитель» или метод посетителя — это поведенческий шаблон проектирования, который позволяет определить новую операцию без изменения классов элементов, с которыми она работает. 

## Задача
>_Давайте рассмотрим простой пример шаблона проектирования «Посетитель» на C++ с использованием набора геометрических фигур (элементов) и набора операций (посетителей), которые можно выполнять с этими фигурами._
## Ключевые компоненты паттерна Посетитель
* __Интерфейс для посетителей__ Объявляет метод посещения для каждого конкретного типа элемента.
* __Конкретный Посетитель__ Реализует методы посещения, объявленные в интерфейсе Visitor.
* __Интерфейс элемента__ Объявляет метод accept, который принимает посетителя в качестве аргумента.
* __Конкретный элемент__ Реализует метод accept, вызывая соответствующий visit метод посетителя.
* __Структура объекта__ Представляет собой совокупность или структуру элементов.
## Диаграмма паттерна Посетитель
<figure>
    <img src ="/assets/images/Diagram_Visitor.jpg" alt = "Visitor">
</figure>

## Пример
```c++
#include <iostream>

class ConcreteElementA;
class ConcreteElementB;

class Visitor {
public:
    virtual void visit(ConcreteElementA* el) = 0;
    virtual void visit(ConcreteElementB* el) = 0;
};

class Element {
public:
    virtual void accept(Visitor* v) = 0;
};

class ConcreteElementA : public Element {
public:
    void accept(Visitor* v) override { v->visit(this); }
    std::string featureA() { return "Element A"; }
};

class ConcreteElementB : public Element {
public:
    void accept(Visitor* v) override { v->visit(this); }
    std::string featureB() { return "Element B"; }
};

class ConcreteVisitor : public Visitor {
public:
    void visit(ConcreteElementA* el) override {
        std::cout << "Visitor processes " << el->featureA() << std::endl;
    }
    void visit(ConcreteElementB* el) override {
        std::cout << "Visitor processes " << el->featureB() << std::endl;
    }
};

int main() {
    ConcreteElementA elementA;
    ConcreteElementB elementB;
    ConcreteVisitor visitor;

    elementA.accept(&visitor);  
    elementB.accept(&visitor);  

    return 0;
}
```
## Преимущества шаблона проектирования Visitor
✅ __Разделение задач:__ шаблон проектирования «Посетитель» помогает отделить задачи алгоритма от структуры объектов, с которыми он работает. Это способствует созданию чистой и модульной структуры за счёт группировки связанных операций в классе посетителя.

✅ __Принцип открытости/закрытости:__ шаблон соответствует принципу открытости/закрытости, который гласит, что класс должен быть открыт для расширения, но закрыт для модификации. мы можем добавлять новые операции (посетители) без изменения существующего кода посещаемых элементов.

✅ __Расширяемость:__ позволяет добавлять новые операции в существующие классы без их изменения. Это упрощает расширение функциональности набора классов за счёт добавления новых посетителей.

✅ __Двойная диспетчеризация:__ шаблон проектирования «Посетитель» реализует форму двойной диспетчеризации, при которой вызываемый метод определяется во время выполнения в зависимости от типа как посетителя, так и посещаемого элемента. Это обеспечивает более динамичное и гибкое поведение.

✅ __Удобство сопровождения:__ шаблон проектирования «Посетитель» упрощает сопровождение кода и управление им, поскольку каждая операция инкапсулирована в отдельный класс-посетитель. Если нам нужно внести изменения или добавить новую функциональность, мы можем сделать это в классе-посетителе, не затрагивая посещаемые элементы.

✅ __Улучшенная читаемость:__ этот шаблон позволяет улучшить читаемость кода за счёт централизации операций в отдельных классах посетителей. Это может сделать код более понятным и удобным в сопровождении, особенно при работе со сложными алгоритмами.

✅ __Повторное использование посетителей:__ посетителей можно использовать повторно в различных структурах элементов. Определив посетителя, мы можем использовать его с различными наборами элементов, реализующих один и тот же интерфейс, что обеспечивает высокую степень повторного использования.

## Недостатки шаблона проектирования Visitor
❌ __Повышенная сложность:__ шаблон проектирования «Посетитель» может усложнить код, особенно если речь идёт о простых объектных структурах или операциях. Необходимость определять отдельные классы посетителей для каждой операции может привести к увеличению количества классов и взаимодействий.
Связь между классами посетителей и элементами: добавление новых элементов или изменение структуры существующих элементов может повлиять на все классы посетителей, что потенциально может привести к сильной связи между классами элементов и посетителей.

❌ __Сложность добавления новых элементов:__ для добавления нового элемента в структуру объекта необходимо изменить все существующие классы посетителей, чтобы они могли работать с новым элементом. Это нарушает принцип открытости/закрытости, так как система не закрывается для внесения изменений при добавлении новых элементов.

❌ __Нарушение инкапсуляции:__ чтобы применить шаблон проектирования «Посетитель», посещаемые элементы должны предоставлять посетителю доступ к своей внутренней структуре. Это может привести к нарушению инкапсуляции, поскольку посетителю нужен доступ к внутренним компонентам элементов.

❌ __Модификация интерфейса приемки:__ в классах элементов должен быть определен метод "принять", чтобы посетители могли их посещать. Если набор возможных операций (посетителей) часто меняется, это может привести к модификации интерфейса приемки, которая затронет все классы элементов.

❌ __Сложность отладки:__ этот шаблон может усложнить отладку и понимание кода, особенно для разработчиков, не знакомых с шаблоном «Посетитель». Логика операции распределена между несколькими классами посетителей, которые могут быть разбросаны по всей кодовой базе.

❌ __Потенциальные накладные расходы:__ для простых систем или операций шаблон проектирования «Посетитель» может привести к ненужным накладным расходам, связанным с дополнительными классами и вызовами методов. В таких случаях предпочтительнее использовать более простой подход.

❌ __Кривая обучения:__ разработчикам, не знакомым с паттерном «Посетитель», может быть сложно его понять и применить. Этот паттерн предполагает особый способ структурирования кода, и его преимущества могут быть неочевидны.

## Где применяется?
1. Компиляторы (анализ AST).
2. Сериализация/десериализация.