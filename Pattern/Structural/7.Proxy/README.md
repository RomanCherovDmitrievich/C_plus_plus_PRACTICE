# 7. Заместитель (Proxy)

Суть: Контролирует доступ к объекту, добавляя дополнительную логику.

Шаблон проектирования «Прокси» — это структурный шаблон проектирования, который предоставляет суррогат или заполнитель для другого объекта, позволяя контролировать доступ к нему. Этот шаблон может быть особенно полезен в ситуациях, когда необходимо добавить дополнительный уровень контроля, отложенную загрузку или удалённый доступ к объектам.

>Проще говоря, шаблон проектирования «Прокси» — это как если бы у вас был посредник (прокси), который решал бы, когда нужно обратиться за помощью к настоящему эксперту (реальному объекту), а когда можно справиться самостоятельно. Это способ управлять доступом к чьим-либо навыкам и контролировать его, не беспокоя человека без необходимости.

## Ключевые компоненты паттерна Заместитель
1. __Тема:__
Способность вашего друга решать головоломки похожа на Тема. Это то, что вам нужно, — умение решать головоломки.
2. __Реальный объект:__
В данном случае ваш друг — это Реальный объект. Он может очень хорошо решать головоломки, но вам может потребоваться некоторое время и усилия, чтобы обращаться к нему за помощью каждый раз.
3. __Прокси:__
Теперь давайте представим Прокси. В этом сценарии прокси может быть ваш друг, который выступает в роли посредника. Когда вам нужно решить головоломку, вы обращаетесь к этому другу-прокси. Друг-прокси решает, достаточно ли проста головоломка, чтобы справиться с ней самостоятельно. Если головоломка сложная, он попросит помощи у вашего друга, который разбирается в головоломках.

## Пример
```c++
class Image {
public:
    virtual void display() = 0;
};

class RealImage : public Image {
private:
    std::string filename;
public:
    RealImage(const std::string& filename) : filename(filename) {
        loadFromDisk();
    }
    void loadFromDisk() {
        std::cout << "Loading " << filename << std::endl;
    }
    void display() override {
        std::cout << "Displaying " << filename << std::endl;
    }
};

class ProxyImage : public Image {
private:
    RealImage* realImage = nullptr;
    std::string filename;
public:
    ProxyImage(const std::string& filename) : filename(filename) {}
    void display() override {
        if (!realImage) {
            realImage = new RealImage(filename);  // Ленивая загрузка
        }
        realImage->display();
    }
    ~ProxyImage() { delete realImage; }
};

int main() {
    Image* image = new ProxyImage("photo.jpg");
    image->display();  // Только здесь загрузится изображение
    delete image;
    return 0;
}
```
## Преимущества шаблона проектирования Приспособленец
✅ __Управление:__ Шаблон проектирования «Прокси» позволяет контролировать доступ к реальному объекту, добавляя дополнительные функции или проверки безопасности без изменения самого объекта.

✅ __Отложенная загрузка:__ С помощью виртуальных прокси можно отложить создание ресурсоёмких объектов до тех пор, пока они действительно не понадобятся, что повышает производительность.

✅ __Удаленный доступ:__ В распределенных системах шаблон проектирования «Прокси» позволяет прозрачно получать доступ к объектам в разных адресных пространствах.

✅ __Безопасность:__ Прокси-серверы для защиты могут обеспечивать контроль доступа и проверку безопасности, предотвращая несанкционированный доступ к реальному субъекту.


## Недостатки шаблона проектирования Фасад
❌ __Сложность:__ Внедрение прокси-классов может усложнить кодовую базу, что затруднит её поддержку и понимание.

❌ __Накладные расходы:__ В некоторых случаях использование прокси-серверов может привести к дополнительным вызовам методов и косвенному обращению, что потенциально может повлиять на производительность.

❌ __Техническое обслуживание:__ Синхронизировать прокси с изменениями в реальном объекте может быть непросто.

❌ __Неправильное использование:__ При неразумном использовании шаблон проектирования «Прокси» может привести к избыточному коду и чрезмерно сложной системе.


## Где применяется?
1. Отложенная загрузка
2. Контроль доступа
3. Кэширование
4. Ведение журнала и мониторинг