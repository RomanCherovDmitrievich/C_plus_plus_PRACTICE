# Интерфейсы
__Интерфейс__ -  это абстрактный тип, определяющий контракт (набор методов), который должны реализовать классы.
_В C++ интерфейсы эмулируются через абстрактные классы с чисто виртуальными функциями (= 0). Они не содержат реализацию, только сигнатуры методов._

Работает через наследование и реализацию всех методов интерфейса.

# Пример
```c++
class ILoggable {
public:
    virtual void log(const string& message) = 0;
};

class ConsoleLogger : public ILoggable {
public:
    void log(const string& message) override {
        cout << "LOG: " << message << endl;
    }
};
```

# Виды интерфейсов
## Чистые интерфейсы (Pure Interfaces)
Содержат только чисто виртуальные методы (без полей и реализации).
```c++
class IPrintable {
public:
    virtual void print() const = 0; // Чисто виртуальный метод
    virtual ~IPrintable() = default; // Виртуальный деструктор (важно!)
};
```
## Интерфейсы с дефолтной реализацией
Могут включать виртуальные методы с реализацией (для опционального переопределения).
Полезны для добавления базовой логики.

```c++
class ILogger {
public:
    virtual void log(const std::string& message) = 0;
    virtual void logError(const std::string& error) {
        log("[ERROR] " + error); // Дефолтная реализация
    }
};
```

## Интерфейсы с статическими методами
Редкий случай, но иногда используются для фабрик или утилит.

```c++
class IDBFactory {
public:
    static IDatabase* createDatabase(); // Статический метод
};
```
# Для чего нужны интерфейсы?
1. Сокрытие реализации
>Клиентский код работает только с интерфейсом, не зная деталей.
2. Поддержка полиморфизма
>Разные классы могут реализовать один интерфейс по-своему.
3. Тестирование (Mocking)
>Замена реальных зависимостей на "заглушки" (например, MockDatabase вместо SQLDatabase).
4. Соблюдение SOLID
>Принцип Dependency Inversion (зависимость от абстракций, а не деталей).