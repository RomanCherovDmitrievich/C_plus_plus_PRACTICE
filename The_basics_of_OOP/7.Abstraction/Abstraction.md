# Определения 
__Абстракция__ — это один из ключевых принципов ООП, который позволяет скрывать сложную реализацию и показывать только необходимый функционал пользователю.

В C++ абстракция реализуется через:
1. Абстрактные классы (классы с чисто виртуальными функциями)
2. Интерфейсы (частный случай абстрактного класса, где все методы чисто виртуальные)
3. Шаблоны (Templates) (обобщённое программирование)
4. Модули и пространства имён (логическая группировка кода)

>Содержит хотя бы одну чисто виртуальную функцию (= 0).
>Нельзя создать объект такого класса (только через наследников).
>Может иметь реализованные методы и поля.

# Пример
```c++
// Абстрактный класс (есть чисто виртуальный метод)
class Shape {
public:
    virtual double area() const = 0; // Чисто виртуальная функция
    virtual void draw() const {      // Виртуальная функция с реализацией
        cout << "Drawing a shape..." << endl;
    }
};

// Конкретный класс-наследник
class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() const override { // Обязательная реализация
        return 3.14 * radius * radius;
    }
    void draw() const override {   // Переопределение (не обязательно)
        cout << "Drawing a circle with radius " << radius << endl;
    }
};

int main() {
    // Shape shape; // Ошибка! Нельзя создать объект абстрактного класса
    Circle circle(5.0);
    cout << "Area: " << circle.area() << endl; // 78.5
    circle.draw(); // Drawing a circle with radius 5
    return 0;
}
```
## Пояснение
__Shape__ — абстрактный класс, потому что содержит area() = 0.
__Circle__ обязан реализовать area(), иначе тоже станет абстрактным.
draw() можно переопределить, но не обязательно.

# Вызов методов класса
Методы можно вызывать:
1. Через объект (если не static):
```c++
Circle c(3.0);
c.draw();
```
2. Через указатель/ссылку на базовый класс (полиморфизм):
```c++
Shape* shape = new Circle(4.0);
shape->draw(); // Вызовется Circle::draw()
delete shape;
```
3. Статические методы (без создания объекта):
```c++
class Math {
public:
    static int square(int x) { return x * x; }
};
cout << Math::square(5); // 25
```

# Работа конструкторов и деструкторов в виртуальном классе
## Пример
Абстрактный класс I1:
```c++
class I1
{
public:
  virtual ~I1(){}

public:
  virtual void foo1() const = 0;
  virtual void foo2() const = 0;
};
```

Наследуемые классы A и B
```c++
class A: public I1
{
public:
  A()
  {
    foo1();
  }
  virtual ~A()
  {
    foo2();
  }

public:
  void foo1() const
  {
    std::cout << "A1::foo1" << std::endl;
  }
  void foo2() const
  {
    std::cout << "A1::foo2" << std::endl;
  }
};

class B: public A
{
public:
  B()
    : A()
  {
    foo1();
  }
  virtual ~B()
  {
    foo2();
  }

public:
  void foo1() const
  {
    std::cout << "B1::foo1" << std::endl;
  }
  void foo2() const
  {
    std::cout << "B1::foo2" << std::endl;
  }
};
```

Функция main:
```c++
int main()
{
  I1* i = new A(); // Вывод: A1::foo1
  //foo(i);
  delete i; // Вывод A1::foo2
  I1* i = new B(); // Вывод A1::foo1 B1::foo1
  //foo(i);
  delete i; // Вывод B1::foo2 A1::foo2

  return 0;
}
```

## Объяснение

При создании абстрактного класса I1 создаётся таблица vtable. Она указывает на null

После при создании класса-наследника A и B созданные объекты ( I1* i = new A() ) указывают на таблицу vtable ( для каждого класса своя таблица vtable), которая указывает на конкретную реализацию функции foo()

При вызове конструктора идут следующие шаги:
1. Вызов конструкторов предков
2. Создание таблицы vtable 
3. Секция инициализаци 
4. Тело конструктора

Когда вызывается деструктор ( деструктор в абстрактном классе всегда виртуальный), то идут шаги в обратном направлении:
1. Тело деструктора
2. Вызов деструкторов предков 
3. Освобождение памяти

# Замечания
## Ошибка pure virtual member function 'foo1'
При попытке в абстрактном классе в конструкторе вызвать функцию без реализации, выводит ошибку, так как функция указывает на значение null в таблице vtable
```c++
class I1
{
public:
  I1()
  {
    foo1;
  }
  virtual foo1() = 0;
}  
```
